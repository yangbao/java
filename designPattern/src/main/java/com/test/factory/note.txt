1. 静态工厂（简单工厂，单例、多例）
    简单工厂模式是由（一个）工厂（注意是一个！）对象决定创建出哪一种产品类的实例
    简单工厂是一个工厂只生产一类的产品,面对的是具体的类,
    实现方式的实质：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。
    简单工厂模式简单工厂模式的适用场景：
     （1）需要创建的对象较少。
     （2）客户端不关心对象的创建过程。
    优点：
        通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利。
    不足：
        用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）
        由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
        当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；
        简单工厂的问题：只是将创建过程移动到了工厂类里，扩展，删除仍然需要修改代码。但是确实减少了代码的重复。而且不对具体类编程

2. 普通工厂
    任意定制产品的类型和生产过程
适用场景：
　　（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了。
　　（2）客户端可以通过子类来指定创建对应的对象。
优缺点：
    简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂
    好处：增加一个新的产品，只需要增加产品类和相对应的工厂，两个类，不需要修改工厂类。
    缺点：增加运算类，会修改客户端代码，工厂方法只是把简单工厂的内部逻辑判断移到了客户端进行。
          还有对系列产品会比较麻烦，比如图片工厂，除了展示功能外，再加上特效展示的功能，需要修改很多。
3. 抽象工厂
    产生系列产品
适用场景：
    (1) 和工厂方法一样客户端不需要知道它所创建的对象的类。
   （2) 需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。
   （3) 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）
优缺点：
    缺点：解决了系列产品问题，但是并不能任意扩展产品和定制过程，修改会很多
    优点：向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象
区别：
    工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。
    工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个
4.bean工厂， 反射+ 普通工厂+配置文件
    配置文件读取后放到Map里面，需要的时候再调用。
    基于接口的类型任意定制
    一定程度的生产过程定制（AOP）












